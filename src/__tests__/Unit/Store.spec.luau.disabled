local ReplicatedStorage = game:GetService("ReplicatedStorage")

local JestGlobals = require(ReplicatedStorage.DevPackages.JestGlobals)
local Constants = require(ReplicatedStorage.Packages.Lyra.Constants)
local Promise = require(ReplicatedStorage.Packages.Promise)

local it = JestGlobals.it
local expect = JestGlobals.expect
local describe = JestGlobals.describe
local beforeEach = JestGlobals.beforeEach
local jest = JestGlobals.jest

jest.useFakeTimers()

describe("Store Transaction Race Conditions", function()
	local store
	local schema = function(value)
		return type(value) == "table"
	end

	local function resetStore()
		local MockInterface = require(ReplicatedStorage.Packages.Lyra.DataStoreInterface.MockInterface)
		local createStore = require(ReplicatedStorage.Packages.Lyra.Store).createStore
		store = createStore({
			name = "TestStore",
			template = {},
			schema = schema,
			dataStoreInterface = MockInterface.new({ yields = true }),
		})
	end

	beforeEach(resetStore)

	it("should handle concurrent writes to the same key", function()
		local tx1 = store:lock("testKey"):andThen(function()
			return store:tx({ "testKey" }, function(state)
				state.testKey.someData = "tx1"
				return state
			end)
		end)

		local tx2 = store:lock("testKey"):andThen(function()
			return store:tx({ "testKey" }, function(state)
				state.testKey.someData = "tx2"
				return state
			end)
		end)

		jest.runAllTimers()

		return Promise.all({ tx1, tx2 })
			:andThen(function()
				local finalState = store._keyEntries["testKey"].data.someData
				expect(finalState == "tx1" or finalState == "tx2").toBe(true)
			end)
			:catch(error)
	end)

	it("should handle sequential transaction dependencies", function()
		local tx1 = store:lock("testKey"):andThen(function()
			return store:tx({ "testKey" }, function(state)
				state.testKey.someData = "tx1"
				return state
			end)
		end)

		jest.runAllTimers()

		return tx1:andThen(function()
			local tx2 = store:tx({ "testKey" }, function(state)
				state.testKey.someData = state.testKey.someData .. "tx2"
				return state
			end)

			jest.runAllTimers()

			return tx2:andThen(function()
				expect(store._keyEntries["testKey"].data.someData).toBe("tx1tx2")
			end)
		end):catch(error)
	end)

	it("should handle cross-key dependencies", function()
		local tx1 = store
			:lock("testKey1")
			:andThen(function()
				return store:lock("testKey2")
			end)
			:andThen(function()
				return store:tx({ "testKey1", "testKey2" }, function(state)
					state.testKey1.someData = "tx1"
					state.testKey2.someData = "tx1"
					return state
				end)
			end)

		jest.runAllTimers()

		return tx1:andThen(function()
			local tx2 = store:tx({ "testKey1", "testKey2" }, function(state)
				state.testKey1.someData ..= "tx2"
				state.testKey2.someData ..= "tx2"
				return state
			end)

			jest.runAllTimers()

			return tx2:andThen(function()
				expect(store._keyEntries["testKey1"].data.someData).toBe("tx1tx2")
				expect(store._keyEntries["testKey2"].data.someData).toBe("tx1tx2")
			end)
		end):catch(error)
	end)

	it("should handle simultaneous lock and unlock operations", function()
		local p = store
			:lock("testKey")
			:andThen(function()
				return store:unlock("testKey")
			end)
			:catch(error)

		jest.runAllTimers()

		return p:andThen(function()
			expect(store._keyEntries["testKey"]).toBe(nil)
		end)
	end)

	it("should handle transaction overlaps", function()
		local locks = Promise.all({
			store:lock("testKey1"),
			store:lock("testKey2"),
			store:lock("testKey3"),
		})

		local tx1 = locks:andThen(function()
			return store:tx({ "testKey1", "testKey2" }, function(state)
				state.testKey1.someData = "tx1"
				state.testKey2.someData = "tx1"
				return state
			end)
		end)

		local tx2 = locks:andThen(function()
			return store:tx({ "testKey2", "testKey3" }, function(state)
				state.testKey2.someData ..= "tx2"
				state.testKey3.someData = "tx2"
				return state
			end)
		end)

		jest.runAllTimers()

		return Promise.all({ tx1, tx2 })
			:andThen(function()
				expect(store._keyEntries["testKey1"].data.someData).toBe("tx1")
				expect(store._keyEntries["testKey2"].data.someData).toBe("tx1tx2")
				expect(store._keyEntries["testKey3"].data.someData).toBe("tx2")
			end)
			:catch(error)
	end)

	it("should not allow yielding in transaction callbacks", function()
		local p = store:lock("testKey"):andThen(function()
			return store:tx({ "testKey" }, function(state)
				coroutine.yield()
				state.testKey.someData = "invalid"
				return state
			end)
		end)

		jest.runAllTimers()

		return expect(function()
			return p:expect()
		end).toThrow("attempt to yield")
	end)

	it("should read txData/committedData when tx is committed/aborted respectively", function()
		return Promise.try(function()
			local p = Promise.all({
				store:lock("testKey1"),
				store:lock("testKey2"),
				store:lock("testKey3"),
				store:lock("testKey4"),
			})

			jest.runAllTimers()
			p:expect()

			p = Promise.all({
				store:update("testKey1", function(data)
					data.someData = "committed"
					return data
				end),
				store:update("testKey2", function(data)
					data.someData = "committed"
					return data
				end),
				store:update("testKey3", function(data)
					data.someData = "committed"
					return data
				end),
				store:update("testKey4", function(data)
					data.someData = "committed"
					return data
				end),
			})

			jest.runAllTimers()
			p:expect()

			p = store:tx({ "testKey1", "testKey2" }, function(state)
				state.testKey1.someData = "tx"
				state.testKey2.someData = "tx"
				return state
			end)

			jest.runAllTimers()
			p:expect()

			local abortTxId
			p = store
				:tx({ "testKey3", "testKey4" }, function(state)
					state.testKey3.someData = "tx"
					state.testKey4.someData = "tx"
					return state
				end)
				:andThen(function()
					abortTxId = store._lastTxId
				end)

			jest.runAllTimers()
			p:expect()

			-- Forcefully abort tx
			p = store._ctx.dataStoreInterface:set(Constants.TX_SCOPE, abortTxId, false)

			jest.runAllTimers()
			p:expect()

			local interface = store._ctx.dataStoreInterface
			resetStore()
			store._ctx.dataStoreInterface = interface

			-- Simulate server dying by advancing time to expire the lock
			jest.setSystemTime(DateTime.now().UnixTimestamp + Constants.LOCK_DURATION_SECONDS + 1)

			p = Promise.all({
				store:lock("testKey1"),
				store:lock("testKey2"),
				store:lock("testKey3"),
				store:lock("testKey4"),
			})

			jest.runAllTimers()
			p:expect()

			expect(store._keyEntries["testKey1"].data.someData).toBe("tx")
			expect(store._keyEntries["testKey2"].data.someData).toBe("tx")
			expect(store._keyEntries["testKey3"].data.someData).toBe("committed")
			expect(store._keyEntries["testKey4"].data.someData).toBe("committed")
		end)
	end)
end)
