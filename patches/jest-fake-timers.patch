--- a/DevPackages/_Index/jsdotlua_jest-fake-timers@3.6.1-rc.2/jest-fake-timers/src/init.lua	2024-12-12 15:53:59.866889600 -0800
+++ b/DevPackages/_Index/jsdotlua_jest-fake-timers@3.6.1-rc.2/jest-fake-timers/src/init.lua	2024-12-12 18:42:46.156161000 -0800
@@ -84,6 +84,7 @@
 	local taskOverride = {
 		delay = mock:fn(realTask.delay),
 		cancel = mock:fn(realTask.cancel),
+		wait = mock:fn(realTask.wait),
 	}
 	setmetatable(taskOverride, { __index = realTask })
 
@@ -220,10 +221,15 @@
 		self.osOverride.clock.mockImplementation(realOs.clock)
 		self.taskOverride.delay.mockImplementation(realTask.delay)
 		self.taskOverride.cancel.mockImplementation(realTask.cancel)
+		self.taskOverride.wait.mockImplementation(realTask.wait)
 		self._fakingTime = false
 	end
 end
 
+local function fakeClock(self): number
+	return self._mockTimeMs / 1000
+end
+
 local function fakeDelay(self, delayTime, callback, ...): Timeout
 	-- Small hack to make sure 0 second recursive timers don't trigger twice in a single frame
 	local delayTimeMs = (self._engineFrameTime / 1000) + delayTime * 1000
@@ -255,6 +261,21 @@
 			break
 		end
 	end
+	if typeof(timeout) == "thread" then
+		realTask.cancel(timeout)
+	end
+end
+
+local function fakeWait(self, timeToWait: number?)
+	local running = coroutine.running()
+	local clock = fakeClock(self)
+	fakeDelay(self, timeToWait or 0, function()
+		if coroutine.status(running) ~= "suspended" then
+			return
+		end
+		realTask.spawn(running, fakeClock(self) - clock)
+	end)
+	return coroutine.yield()
 end
 
 function FakeTimers:useFakeTimers(): ()
@@ -262,15 +283,19 @@
 		self.delayOverride.mockImplementation(function(delayTime, callback)
 			return fakeDelay(self, delayTime, callback)
 		end)
+
 		self.tickOverride.mockImplementation(function()
 			return self._mockSystemTime
 		end)
+
 		self.timeOverride.mockImplementation(function()
-			return self._mockTimeMs / 1000
+			return fakeClock(self)
 		end)
+
 		self.dateTimeOverride.now.mockImplementation(function()
 			return realDateTime.fromUnixTimestamp(self._mockSystemTime)
 		end)
+
 		self.osOverride.time.mockImplementation(function(time_)
 			if typeof(time_) == "table" then
 				local unixTime = realDateTime.fromUniversalTime(
@@ -285,9 +310,11 @@
 			end
 			return self._mockSystemTime
 		end)
+
 		self.osOverride.clock.mockImplementation(function()
-			return self._mockTimeMs / 1000
+			return fakeClock(self)
 		end)
+
 		self.taskOverride.delay.mockImplementation(function(delayTime, callback, ...)
 			return fakeDelay(self, delayTime, callback, ...)
 		end)
@@ -296,6 +323,10 @@
 			fakeCancel(self, timeout)
 		end)
 
+		self.taskOverride.wait.mockImplementation(function(timeToWait)
+			return fakeWait(self, timeToWait)
+		end)
+
 		self._fakingTime = true
 		self:reset()
 	end
@@ -355,7 +386,8 @@
 function FakeTimers:_checkFakeTimers()
 	if not self._fakingTime then
 		error(
-			[[A function to advance timers was called but the timers API is not mocked with fake timers. Call `jest.useFakeTimers()` in this test.]]
+			"A function to advance timers was called but the timers API is not "
+				.. "mocked with fake timers. Call `jest.useFakeTimers()` in this test."
 		)
 	end
 
